Index: app/src/main/java/com/example/pic_pho/LoginActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.pic_pho\n\nimport android.Manifest\nimport android.app.Activity\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Build\nimport android.os.Bundle\nimport android.util.Base64\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport com.example.pic_pho.CellularSocket.SocketUtil\nimport com.example.pic_pho.WaitingRoomServer.ServerWaitingRoomActivity\nimport com.github.nkzawa.socketio.client.Socket\nimport com.google.firebase.iid.FirebaseInstanceId\nimport com.kakao.sdk.auth.model.OAuthToken\nimport com.kakao.sdk.common.model.AuthErrorCause.*\nimport com.kakao.sdk.user.UserApiClient\nimport kotlinx.android.synthetic.main.activity_login.*\nimport java.security.MessageDigest\n\nclass LoginActivity : AppCompatActivity() {\n    private val TAG = \"LoginActivity\"\n    lateinit var mSocket: Socket;\n\n    //친구 초대 받았을 때\n    lateinit var intentfromfirebase: Intent // = getIntent()\n\n\n    val callBack: (OAuthToken?, Throwable?) -> Unit = { token, error ->\n\n        if (error != null) {\n            Log.d(TAG, \"token ${token} error ${error}\")\n            when {\n                error.toString() == AccessDenied.toString() -> {\n                    Toast.makeText(this, \"접근이 거부 됨(동의 취소)\", Toast.LENGTH_SHORT).show()\n                }\n                error.toString() == InvalidClient.toString() -> {\n                    Toast.makeText(this, \"유효하지 않은 앱\", Toast.LENGTH_SHORT).show()\n                }\n                error.toString() == InvalidGrant.toString() -> {\n                    Toast.makeText(this, \"인증 수단이 유효하지 않아 인증할 수 없는 상태\", Toast.LENGTH_SHORT)\n                        .show()\n                }\n                error.toString() == InvalidRequest.toString() -> {\n                    Toast.makeText(this, \"요청 파라미터 오류\", Toast.LENGTH_SHORT).show()\n                }\n                error.toString() == InvalidScope.toString() -> {\n                    Toast.makeText(this, \"유효하지 않은 scope ID\", Toast.LENGTH_SHORT).show()\n                }\n                error.toString() == Misconfigured.toString() -> {\n                    Toast.makeText(\n                        this,\n                        \"설정이 올바르지 않음(android key hash)\",\n                        Toast.LENGTH_SHORT\n                    ).show()\n                }\n                error.toString() == ServerError.toString() -> {\n                    Toast.makeText(this, \"서버 내부 에러\", Toast.LENGTH_SHORT).show()\n                }\n                error.toString() == Unauthorized.toString() -> {\n                    Toast.makeText(this, \"앱이 요청 권한이 없음\", Toast.LENGTH_SHORT).show()\n                }\n                else -> { // Unknown\n                    Log.e(TAG, \"로그인 실패\", error)\n                    Log.d(TAG, \"onCreate: ${error}\")\n                    Toast.makeText(this, \"기타 에러\", Toast.LENGTH_SHORT).show()\n                }\n            }\n        } else if (token != null) {\n            Log.d(TAG, \"token ${token} error ${error}\")\n            Log.i(TAG, \"로그인 성공 ${token.accessToken}\")\n            Toast.makeText(this, \"로그인에 성공하였습니다.\", Toast.LENGTH_SHORT).show()\n\n            //로그인 정보 서버에 등록\n            //서버에 고객정보 저장\n            registerMemberToServer()\n\n//***********************\n//                val intent = Intent(this, SelectP2pOrServerActivity::class.java)\n//                startActivity(intent)\n\n            if (roomAddress.isNullOrEmpty()) {\n                val intent = Intent(this, SelectP2pOrServerActivity::class.java)\n                startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))\n            } else {\n                val intent = Intent(this, ServerWaitingRoomActivity::class.java)\n                intent.putExtra(\"roomAddress\", roomAddress)\n                startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))\n            }\n        }\n    }\n\n    companion object {\n        var roomAddress: String? = null\n\n\n        fun requestPermissionToUser(activity: Activity) {\n            var writePermission =\n                ContextCompat.checkSelfPermission(\n                    App.instance,\n                    Manifest.permission.WRITE_EXTERNAL_STORAGE\n                )\n            var readPermission =\n                ContextCompat.checkSelfPermission(\n                    App.instance,\n                    Manifest.permission.READ_EXTERNAL_STORAGE\n                )\n            var locationPermission =\n                ContextCompat.checkSelfPermission(\n                    App.instance,\n                    Manifest.permission.ACCESS_FINE_LOCATION\n                )\n            var recordAudioPermission =\n                ContextCompat.checkSelfPermission(App.instance, Manifest.permission.RECORD_AUDIO)\n\n            if (writePermission == PackageManager.PERMISSION_DENIED\n                || readPermission == PackageManager.PERMISSION_DENIED\n                || locationPermission == PackageManager.PERMISSION_DENIED\n                || recordAudioPermission == PackageManager.PERMISSION_DENIED\n            ) {\n                ActivityCompat.requestPermissions(\n                    activity,\n                    arrayOf(\n                        Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        Manifest.permission.READ_EXTERNAL_STORAGE,\n                        Manifest.permission.ACCESS_FINE_LOCATION,\n                        Manifest.permission.RECORD_AUDIO\n                    ),\n                    1\n                )\n            }\n        }\n\n\n    }\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_login)\n\n        UserApiClient.instance.accessTokenInfo { tokenInfo, error ->\n            if (error != null) {\n                Toast.makeText(this, \"토큰 정보 보기 실패\", Toast.LENGTH_SHORT).show()\n            } else if (tokenInfo != null) {\n                Toast.makeText(this, \"토큰 정보 보기 성공\", Toast.LENGTH_SHORT).show()\n\n                if (roomAddress.isNullOrEmpty()) {\n                    val intent = Intent(this, SelectP2pOrServerActivity::class.java)\n                    startActivity(intent)\n                    finish()\n                } else {\n//                    val intent = Intent(this, ServerWaitingRoomActivity::class.java)\n//                    intent.putExtra(\"roomAddress\", roomAddress)\n//                    intent.putExtra(\"test\", \"3\")\n//                    startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))\n                }\n            }\n        }\n\n        //일단 초대 받은거면 방 번호를 받아둔다.\n        roomAddress = null\n        intentfromfirebase = getIntent()\n        if (intentfromfirebase != null) {\n            roomAddress = intentfromfirebase.extras?.getString(\"roomAddress\")\n            Toast.makeText(this, \"${roomAddress}\", Toast.LENGTH_SHORT).show()\n\n            //note 초대를 받아서 로그인창으로 넘어오는 경우.\n            if (roomAddress != null) {\n                UserApiClient.instance.accessTokenInfo { tokenInfo, error ->\n                    if (error != null) {\n                        Toast.makeText(this, \"초대 받았으나 로그인 되어있지 않음.\", Toast.LENGTH_SHORT).show()\n                    } else if (tokenInfo != null) {\n                        var waitingroomIntent: Intent =\n                            Intent(this, ServerWaitingRoomActivity::class.java)\n                        intent.putExtra(\"roomAddress\", roomAddress)\n                        startActivity(waitingroomIntent)\n                        finish()\n                    }\n                }\n\n            }\n        }\n\n        requestPermissionToUser(this) //todo : Wifi 사용 중인지 점검하는 퍼미션 체크 필요\n\n\n        if (roomAddress.isNullOrEmpty()) {\n\n//        getHash() //디버깅용 해시 얻는 함수\n\n\n        kakao_login_button.setOnClickListener {\n            Log.d(TAG, \"onCreate: kakao_login_button\")\n            if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {\n                UserApiClient.instance.loginWithKakaoTalk(this, callback = callBack)\n            } else {\n                UserApiClient.instance.loginWithKakaoAccount(this, callback = callBack)\n            }\n        }\n\n    }\n\n    fun registerMemberToServer() {\n\n\n\n        UserApiClient.instance.me { user, error ->\n            if (error != null) {\n                Log.e(TAG, \"사용자 정보 요청 실패\", error)\n            } else if (user != null) {\n                mSocket = SocketUtil.createAndConnectSocket()!!\n                var scopes = mutableListOf<String>()\n                if (user.kakaoAccount?.emailNeedsAgreement == true) {\n                    scopes.add(\"account_email\")\n                }\n                if (user.kakaoAccount?.birthdayNeedsAgreement == true) {\n                    scopes.add(\"birthday\")\n                }\n                if (user.kakaoAccount?.birthyearNeedsAgreement == true) {\n                    scopes.add(\"birthyear\")\n                }\n                if (user.kakaoAccount?.genderNeedsAgreement == true) {\n                    scopes.add(\"gender\")\n                }\n                if (user.kakaoAccount?.phoneNumberNeedsAgreement == true) {\n                    scopes.add(\"phone_number\")\n                }\n                if (user.kakaoAccount?.profileNeedsAgreement == true) {\n                    scopes.add(\"profile\")\n                }\n                if (user.kakaoAccount?.ageRangeNeedsAgreement == true) {\n                    scopes.add(\"age_range\")\n                }\n                if (user.kakaoAccount?.ciNeedsAgreement == true) {\n                    scopes.add(\"account_ci\")\n                }\n\n                if (scopes.count() > 0) {\n                    Log.d(TAG, \"사용자에게 추가 동의를 받아야 합니다.\")\n\n                    UserApiClient.instance.loginWithNewScopes(this, scopes) { token, error ->\n                        if (error != null) {\n                            Log.e(TAG, \"사용자 추가 동의 실패\", error)\n                        } else {\n                            Log.d(TAG, \"allowed scopes: ${token!!.scopes}\")\n\n                            // 사용자 정보 재요청\n                            UserApiClient.instance.me { user, error ->\n                                if (error != null) {\n                                    Log.e(TAG, \"사용자 정보 요청 실패\", error)\n                                    if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {\n                                        UserApiClient.instance.loginWithKakaoTalk(\n                                            this,\n                                            callback = callBack\n                                        )\n                                    } else {\n                                        UserApiClient.instance.loginWithKakaoAccount(\n                                            this,\n                                            callback = callBack\n                                        )\n                                    }\n\n                                } else if (user != null) {\n                                    Log.i(TAG, \"사용자 정보 요청 성공\")\n                                }\n                            }\n                        }\n                    }\n                }\n\n                //send to server id, nickname, profile url\n                val fireBaseToken = FirebaseInstanceId.getInstance().token\n                mSocket.emit(\n                    \"RegisterMemberToDB\",\n                    user.id,\n                    user.kakaoAccount?.profile?.nickname,\n                    user.kakaoAccount?.profile?.profileImageUrl,\n                    fireBaseToken\n                )\n                Log.i(\n                    TAG, \"사용자 정보 요청 성공\" +\n                            \"\\n회원번호: ${user.id}\" +\n                            \"\\n닉네임: ${user.kakaoAccount?.profile?.nickname}\" +\n                            \"\\n프로필사진: ${user.kakaoAccount?.profile?.thumbnailImageUrl}\"\n                )\n                mSocket.disconnect()\n//                mSocket.disconnect()\n            }\n        }\n    }\n\n\n    // 권한 요청 부분(우리는 갤러리를 위한 WRITE / READ, WiFi - D를 위한 LOCATION, INTERNET이 필요함) -> 권한 부분도 구멍이 많아서 처리해줘야함!!!\n\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    fun getHash() {\n        try {\n            val info =\n                packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNING_CERTIFICATES)\n            val signatures = info.signingInfo.apkContentsSigners\n            for (signature in signatures) {\n                val messageDigest: MessageDigest = MessageDigest.getInstance(\"SHA\")\n                messageDigest.update(signature.toByteArray())\n                val key = String(Base64.encode(messageDigest.digest(), 0))\n                Log.d(\"Hash Key: \", \"!@!@!$key!@!@!\")\n            }\n        } catch (e: Exception) {\n            Log.e(\"not fount\", e.toString())\n        }\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/pic_pho/LoginActivity.kt	(revision 62cc028e88373d16c82c87c5ff01d3eb99f236c3)
+++ app/src/main/java/com/example/pic_pho/LoginActivity.kt	(date 1617648065000)
@@ -28,7 +28,7 @@
     lateinit var mSocket: Socket;
 
     //친구 초대 받았을 때
-    lateinit var intentfromfirebase: Intent // = getIntent()
+    lateinit var intentfromfirebase: Intent// = getIntent()
 
 
     val callBack: (OAuthToken?, Throwable?) -> Unit = { token, error ->
@@ -84,20 +84,21 @@
 //                val intent = Intent(this, SelectP2pOrServerActivity::class.java)
 //                startActivity(intent)
 
-            if (roomAddress.isNullOrEmpty()) {
-                val intent = Intent(this, SelectP2pOrServerActivity::class.java)
-                startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
-            } else {
-                val intent = Intent(this, ServerWaitingRoomActivity::class.java)
-                intent.putExtra("roomAddress", roomAddress)
-                startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
-            }
+//            if (roomAddress.isNullOrEmpty()) {/**/
+            val intent = Intent(this, SelectP2pOrServerActivity::class.java)
+            startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
+//            } else {
+//                val intent = Intent(this, ServerWaitingRoomActivity::class.java)
+//                intent.putExtra("roomAddress", roomAddress)
+//                intent.putExtra("test", "1")
+//                startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
+//            }
         }
     }
 
     companion object {
         var roomAddress: String? = null
-
+        var roomName: String? = null
 
         fun requestPermissionToUser(activity: Activity) {
             var writePermission =
@@ -144,56 +145,39 @@
         super.onCreate(savedInstanceState)
         setContentView(R.layout.activity_login)
 
+        requestPermissionToUser(this) //todo : Wifi 사용 중인지 점검하는 퍼미션 체크 필요
+
         UserApiClient.instance.accessTokenInfo { tokenInfo, error ->
             if (error != null) {
                 Toast.makeText(this, "토큰 정보 보기 실패", Toast.LENGTH_SHORT).show()
             } else if (tokenInfo != null) {
                 Toast.makeText(this, "토큰 정보 보기 성공", Toast.LENGTH_SHORT).show()
 
+                intentfromfirebase = getIntent()
+
+                // roomAddr 초기화
+                if(intentfromfirebase != null){
+                    roomAddress = intentfromfirebase.getStringExtra("roomAddress")
+                    roomName = intentfromfirebase.getStringExtra("roomName")
+                    Toast.makeText(this, "${roomAddress}", Toast.LENGTH_SHORT).show()
+                }
+
+                // 알림 받지 않고 접속한 유저
                 if (roomAddress.isNullOrEmpty()) {
                     val intent = Intent(this, SelectP2pOrServerActivity::class.java)
                     startActivity(intent)
                     finish()
+
+                    // 알림 받아서 접속한 유저
                 } else {
-//                    val intent = Intent(this, ServerWaitingRoomActivity::class.java)
-//                    intent.putExtra("roomAddress", roomAddress)
-//                    intent.putExtra("test", "3")
-//                    startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
-                }
-            }
-        }
-
-        //일단 초대 받은거면 방 번호를 받아둔다.
-        roomAddress = null
-        intentfromfirebase = getIntent()
-        if (intentfromfirebase != null) {
-            roomAddress = intentfromfirebase.extras?.getString("roomAddress")
-            Toast.makeText(this, "${roomAddress}", Toast.LENGTH_SHORT).show()
-
-            //note 초대를 받아서 로그인창으로 넘어오는 경우.
-            if (roomAddress != null) {
-                UserApiClient.instance.accessTokenInfo { tokenInfo, error ->
-                    if (error != null) {
-                        Toast.makeText(this, "초대 받았으나 로그인 되어있지 않음.", Toast.LENGTH_SHORT).show()
-                    } else if (tokenInfo != null) {
-                        var waitingroomIntent: Intent =
-                            Intent(this, ServerWaitingRoomActivity::class.java)
-                        intent.putExtra("roomAddress", roomAddress)
-                        startActivity(waitingroomIntent)
-                        finish()
-                    }
+                    val intent = Intent(this, ServerWaitingRoomActivity::class.java)
+                    intent.putExtra("roomAddress", roomAddress)
+                    intent.putExtra("roomName", roomName)
+                    startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP))
+                    finish()
                 }
-
             }
         }
-
-        requestPermissionToUser(this) //todo : Wifi 사용 중인지 점검하는 퍼미션 체크 필요
-
-
-        if (roomAddress.isNullOrEmpty()) {
-
-//        getHash() //디버깅용 해시 얻는 함수
-
 
         kakao_login_button.setOnClickListener {
             Log.d(TAG, "onCreate: kakao_login_button")
@@ -203,13 +187,9 @@
                 UserApiClient.instance.loginWithKakaoAccount(this, callback = callBack)
             }
         }
-
     }
 
     fun registerMemberToServer() {
-
-
-
         UserApiClient.instance.me { user, error ->
             if (error != null) {
                 Log.e(TAG, "사용자 정보 요청 실패", error)
@@ -290,7 +270,6 @@
                             "\n프로필사진: ${user.kakaoAccount?.profile?.thumbnailImageUrl}"
                 )
                 mSocket.disconnect()
-//                mSocket.disconnect()
             }
         }
     }
Index: .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM_[Default_Changelist]/shelved.patch	(revision 62cc028e88373d16c82c87c5ff01d3eb99f236c3)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM_[Default_Changelist]/shelved.patch	(revision 62cc028e88373d16c82c87c5ff01d3eb99f236c3)
@@ -1,499 +0,0 @@
-Index: app/src/main/java/com/example/pic_pho/MakeGroup/MakeGroupActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.example.pic_pho.MakeGroup\n\nimport android.os.Bundle\nimport android.util.Log\nimport android.view.View\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.pic_pho.App\nimport com.example.pic_pho.databinding.ActivityMakeGroupBinding\nimport kotlinx.android.synthetic.main.activity_lobby.*\nimport kotlinx.android.synthetic.main.activity_make_group.*\nimport kotlinx.android.synthetic.main.activity_photoroom.*\n\nclass MakeGroupActivity : AppCompatActivity(), MakeGroupRecyclerViewInterface {\n    val TAG: String = \"로그\"\n    val FriendName : String = \"유키카\"\n\n    var makeGroupModelList = ArrayList<MakeGroupModel>()\n    private lateinit var makeGroupRecyclerAdapter: MakeGroupRecyclerAdapter\n    private lateinit var binding: ActivityMakeGroupBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMakeGroupBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        for(i in 1..20){\n            val groupModel = MakeGroupModel(name = \"$FriendName $i\", profileImage = \"https://static.news.zumst.com/images/56/2020/07/13/9b3da79c82c44b49aedd31860edced9a.jpg\")\n            this.makeGroupModelList.add(groupModel)\n        }\n\n        //어댑터 인스턴스 생성\n        makeGroupRecyclerAdapter = MakeGroupRecyclerAdapter(this)\n        makeGroupRecyclerAdapter.submitList(this.makeGroupModelList)\n\n        friend_list.apply{\n            layoutManager = LinearLayoutManager(this@MakeGroupActivity, LinearLayoutManager.VERTICAL, false)\n            adapter = makeGroupRecyclerAdapter\n        }\n    }\n\n    //function for finish action\n    fun makeGroupAction(view: View){\n        Log.d(TAG, \"MakeGroupActivity - () called\")\n        Toast.makeText(\n            App.instance,\n            \"그룹만들기!!!!!\",\n            Toast.LENGTH_SHORT\n        ).show()\n        finish()\n    }\n\n    override fun onItemClicked() {\n        Log.d(TAG, \"MakeGroupActivity - onItemClicked() called\")\n        Toast.makeText(\n            App.instance,\n            \"유키카!!!!!\",\n            Toast.LENGTH_SHORT\n        ).show()\n\n//        viewKonfetti.build()\n//            .addColors(Color.YELLOW, Color.GREEN, Color.MAGENTA)\n//            .setDirection(0.0, 359.0)\n//            .setSpeed(1f, 5f)\n//            .setFadeOutEnabled(true)\n//            .setTimeToLive(2000L)\n//            .addShapes(Shape.Square, Shape.Circle)\n//            .addSizes(Size(12))\n//            .setPosition(-50f, viewKonfetti.width + 50f, -50f, -50f)\n//            .streamFor(300, 5000L)\n    }\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- app/src/main/java/com/example/pic_pho/MakeGroup/MakeGroupActivity.kt	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ app/src/main/java/com/example/pic_pho/MakeGroup/MakeGroupActivity.kt	(date 1617033702000)
-@@ -8,13 +8,20 @@
- import androidx.recyclerview.widget.LinearLayoutManager
- import com.example.pic_pho.App
- import com.example.pic_pho.databinding.ActivityMakeGroupBinding
-+import com.github.nkzawa.emitter.Emitter
-+import com.github.nkzawa.socketio.client.IO
-+import com.github.nkzawa.socketio.client.Socket
-+import com.kakao.sdk.talk.TalkApiClient
-+import com.kakao.sdk.user.UserApiClient
- import kotlinx.android.synthetic.main.activity_lobby.*
-+import kotlinx.android.synthetic.main.activity_login.*
- import kotlinx.android.synthetic.main.activity_make_group.*
- import kotlinx.android.synthetic.main.activity_photoroom.*
-+import kotlin.concurrent.thread
- 
- class MakeGroupActivity : AppCompatActivity(), MakeGroupRecyclerViewInterface {
-     val TAG: String = "로그"
--    val FriendName : String = "유키카"
-+    val FriendName: String = "유키카"
- 
-     var makeGroupModelList = ArrayList<MakeGroupModel>()
-     private lateinit var makeGroupRecyclerAdapter: MakeGroupRecyclerAdapter
-@@ -22,11 +29,16 @@
- 
-     override fun onCreate(savedInstanceState: Bundle?) {
-         super.onCreate(savedInstanceState)
-+
-+        //친구 목록 표cx
-         binding = ActivityMakeGroupBinding.inflate(layoutInflater)
-         setContentView(binding.root)
- 
--        for(i in 1..20){
--            val groupModel = MakeGroupModel(name = "$FriendName $i", profileImage = "https://static.news.zumst.com/images/56/2020/07/13/9b3da79c82c44b49aedd31860edced9a.jpg")
-+        for (i in 1..20) {
-+            val groupModel = MakeGroupModel(
-+                name = "$FriendName $i",
-+                profileImage = "https://static.news.zumst.com/images/56/2020/07/13/9b3da79c82c44b49aedd31860edced9a.jpg"
-+            )
-             this.makeGroupModelList.add(groupModel)
-         }
- 
-@@ -34,14 +46,37 @@
-         makeGroupRecyclerAdapter = MakeGroupRecyclerAdapter(this)
-         makeGroupRecyclerAdapter.submitList(this.makeGroupModelList)
- 
--        friend_list.apply{
--            layoutManager = LinearLayoutManager(this@MakeGroupActivity, LinearLayoutManager.VERTICAL, false)
-+        friend_list.apply {
-+            layoutManager =
-+                LinearLayoutManager(this@MakeGroupActivity, LinearLayoutManager.VERTICAL, false)
-             adapter = makeGroupRecyclerAdapter
-         }
-+
-+        //초대방 Url 생성
-+        var mSocket: Socket = IO.socket("http://52.78.242.130:5000/") //영동
-+//            mSocket = IO.socket("http://3.35.138.31:5000/") //새힘
-+        thread() {
-+            mSocket.connect()
-+        }
-+        UserApiClient.instance.me { user, error ->
-+            Log.d(TAG, "onCreate: ${user?.id}")
-+            mSocket.emit("createRoom", user?.id)
-+        }
-+
-+
-+        mSocket.on("success", roomtest)
-+
-+
-+    }
-+
-+    var roomtest = Emitter.Listener {
-+        var data = it[0].toString()
-+
-+        Log.d(TAG, "${data}")
-     }
- 
-     //function for finish action
--    fun makeGroupAction(view: View){
-+    fun makeGroupAction(view: View) {
-         Log.d(TAG, "MakeGroupActivity - () called")
-         Toast.makeText(
-             App.instance,
-@@ -70,4 +105,6 @@
- //            .setPosition(-50f, viewKonfetti.width + 50f, -50f, -50f)
- //            .streamFor(300, 5000L)
-     }
-+
-+
- }
-\ No newline at end of file
-Index: app/src/main/java/com/example/pic_pho/LoginActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.example.pic_pho\n\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.util.Base64\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport com.kakao.sdk.auth.model.OAuthToken\nimport com.kakao.sdk.common.model.AuthErrorCause.*\nimport com.kakao.sdk.user.UserApiClient\nimport kotlinx.android.synthetic.main.activity_login.*\nimport java.security.MessageDigest\n\nclass LoginActivity : AppCompatActivity() {\n    private val TAG = \"kakao login\"\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_login)\n        Log.d(TAG, \"onCreate: onCreateonCreate\")\n\n\n\n        kakao_login_button.setOnClickListener {\n            val callback: (OAuthToken?, Throwable?) -> Unit = { token, error ->\n\n                if (error != null) {\n                    Log.d(TAG, \"token ${token} error ${error}\")\n                    when {\n                        error.toString() == AccessDenied.toString() -> {\n                            Toast.makeText(this, \"접근이 거부 됨(동의 취소)\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == InvalidClient.toString() -> {\n                            Toast.makeText(this, \"유효하지 않은 앱\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == InvalidGrant.toString() -> {\n                            Toast.makeText(this, \"인증 수단이 유효하지 않아 인증할 수 없는 상태\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == InvalidRequest.toString() -> {\n                            Toast.makeText(this, \"요청 파라미터 오류\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == InvalidScope.toString() -> {\n                            Toast.makeText(this, \"유효하지 않은 scope ID\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == Misconfigured.toString() -> {\n                            Toast.makeText(\n                                this,\n                                \"설정이 올바르지 않음(android key hash)\",\n                                Toast.LENGTH_SHORT\n                            ).show()\n                        }\n                        error.toString() == ServerError.toString() -> {\n                            Toast.makeText(this, \"서버 내부 에러\", Toast.LENGTH_SHORT).show()\n                        }\n                        error.toString() == Unauthorized.toString() -> {\n                            Toast.makeText(this, \"앱이 요청 권한이 없음\", Toast.LENGTH_SHORT).show()\n                        }\n                        else -> { // Unknown\n                            Log.e(TAG, \"로그인 실패\", error)\n                            Log.d(TAG, \"onCreate: ${error}\")\n                            Toast.makeText(this, \"기타 에러\", Toast.LENGTH_SHORT).show()\n                        }\n                    }\n                }\n                else if (token != null) {\n                    Log.d(TAG, \"token ${token} error ${error}\")\n                    Log.i(TAG, \"로그인 성공 ${token.accessToken}\")\n                    Toast.makeText(this, \"로그인에 성공하였습니다.\", Toast.LENGTH_SHORT).show()\n                    val intent = Intent(this, SelectP2pOrServerActivity::class.java)\n                    startActivity(intent)\n                }\n            }\n\n            //카카오어카운트가 실행이 되지 않는다. 해결해야 할듯\n            Log.d(TAG, \"onCreate: kakao_login_button\")\n            if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {\n                UserApiClient.instance.loginWithKakaoTalk(this, callback = callback)\n            }else{\n                Toast.makeText(this, \"카카오톡이 없어 카카오로그인을 할 수 없습니다.\", Toast.LENGTH_SHORT).show()\n            }\n            //            else {\n//                UserApiClient.instance.loginWithKakaoAccount(this, callback = callback)\n//            }\n\n        }\n\n\n\n//\n        login_button.setOnClickListener {\n            var intent = Intent(this, SelectP2pOrServerActivity::class.java)\n            startActivity(intent)\n            finish()\n        }\n\n        signup_button.setOnClickListener {\n\n            val webIntent: Intent = Uri.parse(\"https://swjungle.net\").let{ webpage ->\n                Intent(Intent.ACTION_VIEW, webpage)\n            }\n            startActivity(webIntent)\n            finish()\n        }\n    }\n\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- app/src/main/java/com/example/pic_pho/LoginActivity.kt	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ app/src/main/java/com/example/pic_pho/LoginActivity.kt	(date 1617038413000)
-@@ -10,21 +10,43 @@
- import android.widget.Toast
- import androidx.annotation.RequiresApi
- import androidx.appcompat.app.AppCompatActivity
-+import com.bumptech.glide.Glide
-+import com.github.nkzawa.emitter.Emitter
-+import com.github.nkzawa.socketio.client.IO
-+import com.github.nkzawa.socketio.client.Socket
- import com.kakao.sdk.auth.model.OAuthToken
- import com.kakao.sdk.common.model.AuthErrorCause.*
-+import com.kakao.sdk.talk.TalkApiClient
- import com.kakao.sdk.user.UserApiClient
- import kotlinx.android.synthetic.main.activity_login.*
-+import kotlinx.android.synthetic.main.activity_select_p2p_or_server.*
-+import java.net.URISyntaxException
- import java.security.MessageDigest
-+import kotlin.concurrent.thread
- 
- class LoginActivity : AppCompatActivity() {
-     private val TAG = "kakao login"
--
-+    lateinit var mSocket: Socket;
-+    @RequiresApi(Build.VERSION_CODES.P)
-     override fun onCreate(savedInstanceState: Bundle?) {
-         super.onCreate(savedInstanceState)
-         setContentView(R.layout.activity_login)
-         Log.d(TAG, "onCreate: onCreateonCreate")
- 
--
-+        try {
-+            val info = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNING_CERTIFICATES)
-+            val signatures = info.signingInfo.apkContentsSigners
-+            val md = MessageDigest.getInstance("SHA")
-+            for (signature in signatures) {
-+                val md: MessageDigest
-+                md = MessageDigest.getInstance("SHA")
-+                md.update(signature.toByteArray())
-+                val key = String(Base64.encode(md.digest(), 0))
-+                Log.d("Hash Key: ", "!@!@!$key!@!@!")
-+            }
-+        } catch (e: Exception) {
-+            Log.e("not fount", e.toString())
-+        }
- 
-         kakao_login_button.setOnClickListener {
-             val callback: (OAuthToken?, Throwable?) -> Unit = { token, error ->
-@@ -71,22 +93,45 @@
-                     Log.d(TAG, "token ${token} error ${error}")
-                     Log.i(TAG, "로그인 성공 ${token.accessToken}")
-                     Toast.makeText(this, "로그인에 성공하였습니다.", Toast.LENGTH_SHORT).show()
-+
-+                    //로그인 정보 서버에 등록
-+                    try {
-+                        mSocket = IO.socket("http://52.78.242.130:5000/") //영동
-+//                         mSocket = IO.socket("http://3.35.138.31:5000/") //새힘
-+                        thread() {
-+                            mSocket.connect()
-+                        }
-+                    } catch (e: URISyntaxException) {
-+                        Log.d(TAG, "failed")
-+                    }
-+
-+                    registerMenberToServer()
-+
-+
-                     val intent = Intent(this, SelectP2pOrServerActivity::class.java)
-                     startActivity(intent)
-                 }
-             }
- 
--            //카카오어카운트가 실행이 되지 않는다. 해결해야 할듯
-+            //카카오 어카운트가 실행이 되지 않는다. 해결해야 할듯
-             Log.d(TAG, "onCreate: kakao_login_button")
-             if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {
-                 UserApiClient.instance.loginWithKakaoTalk(this, callback = callback)
-+//                TalkApiClient.instance.friends { friends, error ->
-+//                    Log.e(TAG, "onCreate: as;'dlkasl;fkadls;'kf;'lsdkf';lkfl;'")
-+//                    if (error != null) {
-+//                        Log.e(TAG, "카카오톡 친구 목록 가져오기 실패", error)
-+//                    }
-+//                    else if (friends != null) {
-+//                        Log.i(TAG, "카카오톡 친구 목록 가져오기 성공 \n${friends.elements.joinToString("\n")}")
-+//
-+//                        // 친구의 UUID 로 메시지 보내기 가능
-+//                    }
-+//                }
-+
-             }else{
--                Toast.makeText(this, "카카오톡이 없어 카카오로그인을 할 수 없습니다.", Toast.LENGTH_SHORT).show()
-+                UserApiClient.instance.loginWithKakaoAccount(this, callback = callback)
-             }
--            //            else {
--//                UserApiClient.instance.loginWithKakaoAccount(this, callback = callback)
--//            }
--
-         }
- 
- 
-@@ -106,6 +151,78 @@
-             startActivity(webIntent)
-             finish()
-         }
-+
-+
-+
-+
-     }
-+
-+    fun registerMenberToServer(){
-+        UserApiClient.instance.me { user, error ->
-+            if (error != null) {
-+                Log.e(TAG, "사용자 정보 요청 실패", error)
-+            } else if (user != null) {
-+                var scopes = mutableListOf<String>()
-+                if (user.kakaoAccount?.emailNeedsAgreement == true) {
-+                    scopes.add("account_email")
-+                }
-+                if (user.kakaoAccount?.birthdayNeedsAgreement == true) {
-+                    scopes.add("birthday")
-+                }
-+                if (user.kakaoAccount?.birthyearNeedsAgreement == true) {
-+                    scopes.add("birthyear")
-+                }
-+                if (user.kakaoAccount?.genderNeedsAgreement == true) {
-+                    scopes.add("gender")
-+                }
-+                if (user.kakaoAccount?.phoneNumberNeedsAgreement == true) {
-+                    scopes.add("phone_number")
-+                }
-+                if (user.kakaoAccount?.profileNeedsAgreement == true) {
-+                    scopes.add("profile")
-+                }
-+                if (user.kakaoAccount?.ageRangeNeedsAgreement == true) {
-+                    scopes.add("age_range")
-+                }
-+                if (user.kakaoAccount?.ciNeedsAgreement == true) {
-+                    scopes.add("account_ci")
-+                }
-+
-+                if (scopes.count() > 0) {
-+                    Log.d(TAG, "사용자에게 추가 동의를 받아야 합니다.")
-+
-+                    UserApiClient.instance.loginWithNewScopes(this, scopes) { token, error ->
-+                        if (error != null) {
-+                            Log.e(TAG, "사용자 추가 동의 실패", error)
-+                        } else {
-+                            Log.d(TAG, "allowed scopes: ${token!!.scopes}")
-+
-+                            // 사용자 정보 재요청
-+                            UserApiClient.instance.me { user, error ->
-+                                if (error != null) {
-+                                    Log.e(TAG, "사용자 정보 요청 실패", error)
-+                                } else if (user != null) {
-+                                    Log.i(TAG, "사용자 정보 요청 성공")
-+                                }
-+                            }
-+                        }
-+                    }
-+                }
-+
-+//                var imageUrl :String= user.kakaoAccount?.profile?.thumbnailImageUrl.toString()
-+//                Glide.with(this).load(imageUrl).into(selectImage);
-+
-+                //send to server id, nickname, profile url
-+                mSocket.emit("registermemer", user.id, user.kakaoAccount?.profile?.nickname, user.kakaoAccount?.profile?.thumbnailImageUrl)
-+                Log.i(
-+                    TAG, "사용자 정보 요청 성공" +
-+                            "\n회원번호: ${user.id}" +
-+                            "\n닉네임: ${user.kakaoAccount?.profile?.nickname}" +
-+                            "\n프로필사진: ${user.kakaoAccount?.profile?.thumbnailImageUrl}"
-+                )
-+            }
-+        }
-+    }
-+
- 
- }
-\ No newline at end of file
-Index: app/build.gradle
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>apply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\n\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n\n    defaultConfig {\n        applicationId \"com.example.pic_pho\"\n        minSdkVersion 21\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    buildFeatures {\n        viewBinding true\n    }\n\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n\n\n}\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n    implementation 'androidx.core:core-ktx:1.3.0'\n    implementation 'androidx.appcompat:appcompat:1.2.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    implementation \"org.jetbrains.anko:anko:$anko_version\"\n\n    //리사이클러 뷰\n    implementation 'androidx.recyclerview:recyclerview:1.1.0'\n    // For control over item selection of both touch and mouse driven selection\n    implementation \"androidx.recyclerview:recyclerview-selection:1.1.0\"\n\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'de.hdodenhof:circleimageview:3.1.0'\n    implementation 'androidx.navigation:navigation-fragment-ktx:2.3.3' // 프래그먼트\n    implementation 'androidx.navigation:navigation-ui-ktx:2.3.3' // 프래그먼트\n    implementation \"com.squareup.retrofit2:retrofit:2.8.1\" // 레트로핏 HTTP 라이브러리\n    implementation \"com.squareup.retrofit2:converter-gson:2.8.1\" // json 형식 parser\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9' // 코루틴\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n\n    //카드 뷰\n    implementation \"androidx.cardview:cardview:1.0.0\"\n\n    //glide - 이미지 처리: 인터넷에서 끌어온 사진 조작하려\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'\n\n    // Ripple Background Library & konfetti\n    implementation 'com.skyfishjy.ripplebackground:library:1.0.1'\n    implementation 'nl.dionsegijn:konfetti:1.3.2'\n\n    //ImageView 둥근 모서리\n    implementation 'de.hdodenhof:circleimageview:3.1.0'\n\n    // 뷰페이져 2\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\n\n    // 압축, 소켓io, 코루틴, 메타데이터\n    implementation 'id.zelory:compressor:3.0.1'\n    implementation 'com.github.nkzawa:socket.io-client:0.3.0'\n    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.2.0'\n    implementation \"androidx.exifinterface:exifinterface:1.3.2\"\n\n    // 카카오 로그인\n    implementation \"com.kakao.sdk:v2-user:2.4.1\"\n\n\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- app/build.gradle	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ app/build.gradle	(date 1617031748000)
-@@ -91,6 +91,7 @@
- 
-     // 카카오 로그인
-     implementation "com.kakao.sdk:v2-user:2.4.1"
-+    implementation "com.kakao.sdk:v2-talk:2.4.1"
- 
- 
- }
-\ No newline at end of file
-Index: app/src/main/java/com/example/pic_pho/App.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.example.pic_pho\n\nimport android.app.Application\nimport com.kakao.sdk.common.KakaoSdk\n\n// context 참조가 안될 때 App.instance 사용하면 가져올 수 있음\nclass App: Application() {\n\n    companion object{\n        lateinit var instance: App\n            private set\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        instance = this\n        KakaoSdk.init(this,\"ece39b60a7c22e79f10be8045187312b\",)\n\n\n\n    }\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- app/src/main/java/com/example/pic_pho/App.kt	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ app/src/main/java/com/example/pic_pho/App.kt	(date 1617032668000)
-@@ -14,6 +14,7 @@
-     override fun onCreate() {
-         super.onCreate()
-         instance = this
-+        //{NATIVE_APP_KEY}
-         KakaoSdk.init(this,"ece39b60a7c22e79f10be8045187312b",)
- 
- 
-Index: app/src/main/java/com/example/pic_pho/PhotoRoomServer/ServerPhotoRoomActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.example.pic_pho.PhotoRoomServer\n\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.media.MediaScannerConnection\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.provider.MediaStore\nimport android.provider.Settings\nimport android.util.Base64\nimport android.util.Log\nimport android.view.View\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.exifinterface.media.ExifInterface\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.viewpager2.widget.ViewPager2\nimport com.example.pic_pho.App\nimport com.example.pic_pho.PhotoRoomServer.ServerThumbnailPhotoModel\nimport com.example.pic_pho.PhotoRoomServer.ServerThumbnailRecyclerViewInterface\nimport com.example.pic_pho.PhotoRoomServer.ViewPager.ServerPhotoRoomPagerAdapter\nimport com.example.pic_pho.PhotoRoomServer.FileUtil\nimport com.example.pic_pho.PhotoRoomServer.ServerThumbnailRecyclerAdapter\nimport com.example.pic_pho.databinding.ActivityServerphotoroomBinding\nimport com.example.pic_pho.databinding.ItemPhotoroomPagerBinding\n\nimport com.github.nkzawa.emitter.Emitter\nimport com.github.nkzawa.socketio.client.IO\nimport com.github.nkzawa.socketio.client.Socket\nimport id.zelory.compressor.Compressor\nimport id.zelory.compressor.constraint.format\nimport id.zelory.compressor.constraint.quality\nimport id.zelory.compressor.loadBitmap\nimport kotlinx.android.synthetic.main.activity_photoroom.*\nimport kotlinx.android.synthetic.main.item_photoroom_pager.*\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport java.io.ByteArrayOutputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.OutputStream\nimport java.net.URISyntaxException\nimport kotlin.concurrent.thread\n\nclass ServerPhotoRoomActivity : AppCompatActivity(), ServerThumbnailRecyclerViewInterface {\n\n    val TAG: String = \"로그\"\n\n    var photoModelList = ArrayList<ServerThumbnailPhotoModel>()\n    lateinit var mSocket: Socket;\n    var returnedImage: Bitmap? = null\n    private var actualImage: File? = null\n    private var compressedImage: File? = null\n    lateinit var exif: ExifInterface\n    private var photoFlag = false\n\n\n    companion object {\n        lateinit var serverThumbnailRecyclerAdapter: ServerThumbnailRecyclerAdapter\n        lateinit var serverPhotoRoomPagerAdapter : ServerPhotoRoomPagerAdapter\n        lateinit var binding: ActivityServerphotoroomBinding\n        lateinit var photobinding: ItemPhotoroomPagerBinding\n\n        fun changeSelectedPhotoByClicked(position : Int){\n            binding.photoroomViewPager.setCurrentItem(position)\n        }\n        fun scanFile(context: Context?, f: File, mimeType: String) {\n            MediaScannerConnection\n                .scanFile(context, arrayOf(f.absolutePath), arrayOf(mimeType), null)\n        }\n\n        fun getExif(file: File) {\n            var exif = ExifInterface(file!!)\n            if (exif != null) {\n                var myAttribute: String? = \"[Exif information] \\n\\n\"\n                myAttribute += \"TAG_DATETIME           ::: \" + exif.getAttribute(ExifInterface.TAG_DATETIME)\n                    .toString() + \"\\n\"\n                myAttribute += \"TAG_ARTIST             ::: \" + exif.getAttribute(ExifInterface.TAG_ARTIST)\n                    .toString() + \"\\n\"\n            }\n        }\n\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        Log.d(TAG, \"onCreate: \")\n        binding = ActivityServerphotoroomBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        try {\n//            mSocket = IO.socket(\"http://52.78.242.130:5000/\")\n            mSocket = IO.socket(\"http://3.35.138.31:5000/\")\n            thread() {\n                mSocket.connect()\n            }\n        } catch (e: URISyntaxException) {\n            Log.d(TAG, \"failed\")\n        }\n\n        mSocket.on(\"picpho\", imageReturn)\n        photoFlag = false\n\n\n\n    }\n\n    override fun onStart() {\n        super.onStart()\n        Log.d(TAG, \"onStart: \")\n        if(!photoFlag) {\n            var intent = Intent(Intent.ACTION_PICK)\n            intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n            intent.data = MediaStore.Images.Media.EXTERNAL_CONTENT_URI\n            intent.type = \"image/*\"\n            startActivityForResult(intent, 100)\n            photoFlag = true\n        }\n\n    }\n    override fun onResume() {\n        super.onResume()\n        photobinding = ItemPhotoroomPagerBinding.inflate(layoutInflater)\n\n        // 인스턴스 생성\n        serverThumbnailRecyclerAdapter = ServerThumbnailRecyclerAdapter(this)\n        serverThumbnailRecyclerAdapter.submitList(this.photoModelList)\n        serverPhotoRoomPagerAdapter = ServerPhotoRoomPagerAdapter(this.photoModelList)\n        photoroom_view_pager.apply {\n            adapter = serverPhotoRoomPagerAdapter\n            orientation = ViewPager2.ORIENTATION_HORIZONTAL\n        }\n        PhotoRoomRecyclerView.apply {\n            layoutManager = LinearLayoutManager(\n                this@ServerPhotoRoomActivity,\n                LinearLayoutManager.HORIZONTAL,\n                false\n            )\n            adapter = serverThumbnailRecyclerAdapter\n        }\n\n    }\n\n    override fun onStop() {\n        super.onStop()\n        Log.d(TAG, \"onStop: \")\n        Log.d(TAG, \"onStop: onStop on PhotoRoomActivity\")\n\n    }\n\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"onDestroy\", \"onDestroy\")\n\n    }\n\n    //function for finish action\n    fun finishAction(view: View) {\n        Log.d(TAG, \"PhotoRoomActivity - () called\")\n        Toast.makeText(\n            App.instance,\n            \"끝내기!!!!!\",\n            Toast.LENGTH_SHORT\n        ).show()\n        finish()\n    }\n\n    @RequiresApi(Build.VERSION_CODES.Q)\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        when (requestCode) {\n            100 -> {\n                if (data != null) {\n                    val count = data?.clipData!!.itemCount\n                    for (i in 0 until count) {\n                        var imageUri = data.clipData!!.getItemAt(i).uri\n                        var taketime: String? = null\n                        var pictureowner: String? = null\n\n\n\n                        //압축\n                        //원본 파일 가져오기\n                        actualImage = FileUtil.from(this, imageUri)\n\n                        //메타정보추출하기\n                        exif = ExifInterface(actualImage!!)\n                        if (exif != null) {\n                            taketime = exif.getAttribute(ExifInterface.TAG_DATETIME).toString()\n//                            pictureowner = exif.getAttribute(ExifInterface.TAG_ARTIST).toString()\n                            var ANDROID_ID: String = Settings.Secure.getString(applicationContext.contentResolver, Settings.Secure.ANDROID_ID)\n                            pictureowner = ANDROID_ID\n                        }\n                        //압축하기\n                        runBlocking {\n                            compressedImage = compressImage(actualImage!!)\n                        }\n\n                        //modelList에 넣어두기\n                        var photoinfo = ServerThumbnailPhotoModel(imageUri, taketime!!, pictureowner!!, i, count)\n                        photoModelList.add(photoinfo)\n\n                        //압축한 파일 보내\n                        var image_string = BitmapToString(loadBitmap(compressedImage!!))\n                        mSocket.emit(\"test\", image_string, taketime, pictureowner, i, count)\n                    }\n                }\n            }\n        }\n    }\n\n    //어플 키자마자 서버에  connect user 하고 프로젝트에 on new user 실행\n    var imageReturn = Emitter.Listener {\n        var data = it[0].toString()\n        var receivedtaketime = it[1].toString()\n        var receivedowner = it[2].toString()\n        var currentorder = it[3].toString()\n        var tocalcount =it[4].toString()\n        returnedImage = convertString64ToImage(data)\n\n        thread() {\n            var filepath: String = \"/sdcard\" + \"/DCIM/Picpho_test/\"\n            var filename: String =\n                \"Picpho_\" + System.currentTimeMillis().toString() + \".jpg\"\n//                \"Picpho_\" + receivedowner + \"_\" + System.currentTimeMillis().toString() + \".jpg\"\n            var file = File(filepath + filename)\n            // 디렉토리 존재하지 않으면 디렉토리 생성\n            val dirs = File(file!!.parent.toString())\n            if (!dirs.exists()) dirs.mkdirs()\n            saveBitmapAsFile(returnedImage!!, file, receivedtaketime, receivedowner)\n            scanFile(this, file!!, \"jpg\")\n\n\n            //modelList에 넣어두기\n//            var photoinfo = ServerThumbnailPhotoModel(Uri.fromFile(file!!))\n            var photoinfo = ServerThumbnailPhotoModel(Uri.fromFile(file!!), receivedtaketime, receivedowner, currentorder.toInt(), tocalcount.toInt())\n            photoModelList.add(photoinfo)\n        }\n\n        runOnUiThread {\n//            try {\n//                imageView1.setImageBitmap(returnedImage)\n//            } catch (e: Exception) {\n//                e.stackTrace\n//            }\n        }\n    }\n\n    suspend fun compressImage(originalImage: File): File? {\n        var ResultImage: File? = null\n        coroutineScope {\n            launch {\n                // Default compression\n                ResultImage = Compressor.compress(this@ServerPhotoRoomActivity, originalImage!!)\n                {\n//                    resolution(1500, 1500)\n                    quality(95)\n                    format(Bitmap.CompressFormat.JPEG)\n//                    size(1_097_152) // 2 MB\n                }\n            }\n        }\n        return ResultImage\n    }\n\n    fun convertString64ToImage(base64String: String): Bitmap {\n        val decodedString = Base64.decode(base64String, Base64.DEFAULT)\n        return BitmapFactory.decodeByteArray(decodedString, 0, decodedString.size)\n    }\n\n    fun BitmapToString(bitmap: Bitmap): String? {\n        val baos = ByteArrayOutputStream() //바이트 배열을 차례대로 읽어 들이기위한 ByteArrayOutputStream클래스 선언\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 90, baos) //bitmap을 압축 (숫자 70은 70%로 압축한다는 뜻)\n        val bytes: ByteArray = baos.toByteArray() //해당 bitmap을 byte배열로 바꿔준다.\n        return Base64.encodeToString(bytes, Base64.DEFAULT) //String을 retrurn\n    }\n\n    fun saveBitmapAsFile(bitmap: Bitmap, file: File, receivedtaketime: String, receivedowner: String) {\n        var os: OutputStream? = null\n        try {\n            file.createNewFile()\n            os = FileOutputStream(file)\n            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os)\n            exif = ExifInterface(file!!)\n            exif.setAttribute(ExifInterface.TAG_DATETIME, receivedtaketime)\n            exif.setAttribute(ExifInterface.TAG_ARTIST, receivedowner)\n            exif.saveAttributes()\n            getExif(file!!)\n            os.close()\n        } catch (e: java.lang.Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    fun saveBitmapAsFile(bitmap: Bitmap, file: File) {\n        var os: OutputStream? = null\n        try {\n            file.createNewFile()\n            os = FileOutputStream(file)\n            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os)\n            os.close()\n        } catch (e: java.lang.Exception) {\n            e.printStackTrace()\n        }\n    }\n\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- app/src/main/java/com/example/pic_pho/PhotoRoomServer/ServerPhotoRoomActivity.kt	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ app/src/main/java/com/example/pic_pho/PhotoRoomServer/ServerPhotoRoomActivity.kt	(date 1616949814000)
-@@ -93,8 +93,8 @@
-         binding = ActivityServerphotoroomBinding.inflate(layoutInflater)
-         setContentView(binding.root)
-         try {
--//            mSocket = IO.socket("http://52.78.242.130:5000/")
--            mSocket = IO.socket("http://3.35.138.31:5000/")
-+            mSocket = IO.socket("http://52.78.242.130:5000/") //영동
-+//            mSocket = IO.socket("http://3.35.138.31:5000/") //새힘
-             thread() {
-                 mSocket.connect()
-             }
-Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM__Default_Changelist_.xml
-===================================================================
---- .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM__Default_Changelist_.xml	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM__Default_Changelist_.xml	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM_[Default_Changelist]" date="1616317746650" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM_[Default_Changelist]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Checkout at 3/21/21 6:09 PM [Default Changelist]" />
--</changelist>
-\ No newline at end of file
-Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM_[Default_Changelist]/shelved.patch
-===================================================================
---- .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM_[Default_Changelist]/shelved.patch	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-+++ .idea/shelf/Uncommitted_changes_before_Checkout_at_3_21_21_6_09_PM_[Default_Changelist]/shelved.patch	(revision 92a56645eb9dbe5492e6a3f179c7c1cb1b8f8bc5)
-@@ -1,143 +0,0 @@
--Index: app/src/main/java/com/example/pic_pho/Lobby/GroupModel.kt
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>package com.example.pic_pho.Lobby\n\nimport android.util.Log\n\nclass GroupModel(var name:String? = null, var profileImage: String? = null){\n    \n    val TAG: String = \"로그\"\n    \n    //기본 생성자\n    init{\n        Log.d(TAG, \": Group Model - init() called\")\n    }\n    \n}
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
----- app/src/main/java/com/example/pic_pho/Lobby/GroupModel.kt	(revision 11603d9e053b9d90d4d3b9e368881341da1bf204)
--+++ app/src/main/java/com/example/pic_pho/Lobby/GroupModel.kt	(date 1616316499000)
--@@ -5,6 +5,7 @@
-- class GroupModel(var name:String? = null, var profileImage: String? = null){
--     
--     val TAG: String = "로그"
--+
--     
--     //기본 생성자
--     init{
--Index: app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectBroadcastReceiver.kt
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>package com.example.pic_pho.WifiDirect\n\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.net.wifi.p2p.WifiP2pDeviceList\nimport android.net.wifi.p2p.WifiP2pInfo\nimport android.net.wifi.p2p.WifiP2pManager\nimport android.os.AsyncTask\nimport android.widget.Toast\nimport com.example.pic_pho.WifiDirect.UI.PeerModel\n\nclass WifiDirectBroadcastReceiver(\n    private val manager: WifiP2pManager,\n    private val channel: WifiP2pManager.Channel,\n    private val mainActivity: WifiDirectMainActivity\n) : BroadcastReceiver() {\n\n    companion object{\n        var ServerThread : AsyncTask<Void, Void, String?>? = null\n    }\n\n    override fun onReceive(context: Context, intent: Intent) {\n        // This method is called when the BroadcastReceiver is receiving an Intent broadcast.\n\n        when(intent.action) {\n\n            // WiFi P2P 활성화 시\n            WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -> {\n                // Determine if Wifi P2P mode is enabled or not, alert\n                // the Activity.\n\n                // WiFi 단말의 상태를 가져온 뒤, enable 상태를 점검한다.\n                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)\n\n                when (state) {\n                    WifiP2pManager.WIFI_P2P_STATE_ENABLED -> {\n                        // Wifi P2P is enabled\n                    }\n                    else -> {\n                        // Wifi P2P is not enabled\n                        Toast.makeText(context, \"Wifi-direct 권한이 없습니다.\", Toast.LENGTH_SHORT).show()\n                        //todo : 권한 신청하는 로직 만들기\n                    }\n                }\n            }\n\n            // 연결 가능한 피어 목록이 변경 시 -> requestPeers 구현\n            WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {\n                // The peer list has changed! We should probably do something about that.\n                Toast.makeText(context, \"WIFI_P2P_PEERS_CHANGED_ACTION\", Toast.LENGTH_SHORT).show()\n\n                manager.requestPeers(channel, object : WifiP2pManager.PeerListListener{\n                    override fun onPeersAvailable(peers: WifiP2pDeviceList?) {\n                        WifiDirectMainActivity.availablePeers.clear()\n                        WifiDirectMainActivity.availablePeers.addAll(peers!!.deviceList)\n                        mainActivity.groupList.clear()\n                        for(peer in peers!!.deviceList){\n//                            PeerRecyclerAdapter.modelList.add(GroupModel(peer.deviceName, peer.deviceAddress, peer.isGroupOwner.toString()))\n                            mainActivity.groupList.add(PeerModel(peer.deviceName, peer.deviceAddress, peer.isGroupOwner.toString()))\n                        }\n//                        availablePeers_In_BR.addAll(peers!!.deviceList)\n                        WifiDirectMainActivity.recyclerview_adapter!!.notifyDataSetChanged()\n                        // todo : recycler adapter list에 값 넣고, notify 해줄 것\n                    }\n                })\n            }\n\n            // WiFi P2P 연결 상태가 변경되었음을 나타냄 -> requestConnectionInfo() 호출\n            WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {\n                // Connection state changed! We should probably do something about that.\n\n                manager.requestConnectionInfo(channel, object: WifiP2pManager.ConnectionInfoListener{\n                    override fun onConnectionInfoAvailable(info: WifiP2pInfo?) {\n//                        actionForRole(context, info!!)\n                        if(info!!.groupFormed && info.isGroupOwner){\n                            WifiDirectMainActivity.textView_OG!!.text = \"서버입니다.\"\n                            ServerThread = FileReceiveServerAsyncTask(context).execute()\n                        }else if(info!!.groupFormed){\n                            WifiDirectMainActivity.textView_OG!!.text = \"클라이언트 입니다\"\n                            WifiDirectMainActivity.groupownerAddr = info.groupOwnerAddress.hostAddress\n                        }\n                    }\n                })\n            }\n\n            // 현재 단말 상태 정보\n            WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -> {\n\n            }\n        }\n    }\n\n}\n
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
----- app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectBroadcastReceiver.kt	(revision 11603d9e053b9d90d4d3b9e368881341da1bf204)
--+++ app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectBroadcastReceiver.kt	(date 1616316499000)
--@@ -1,13 +1,16 @@
-- package com.example.pic_pho.WifiDirect
-- 
--+import android.Manifest
-- import android.content.BroadcastReceiver
-- import android.content.Context
-- import android.content.Intent
--+import android.content.pm.PackageManager
-- import android.net.wifi.p2p.WifiP2pDeviceList
-- import android.net.wifi.p2p.WifiP2pInfo
-- import android.net.wifi.p2p.WifiP2pManager
-- import android.os.AsyncTask
-- import android.widget.Toast
--+import androidx.core.app.ActivityCompat
-- import com.example.pic_pho.WifiDirect.UI.PeerModel
-- 
-- class WifiDirectBroadcastReceiver(
--@@ -31,9 +34,8 @@
--                 // the Activity.
-- 
--                 // WiFi 단말의 상태를 가져온 뒤, enable 상태를 점검한다.
---                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)
-- 
---                when (state) {
--+                when (intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)) {
--                     WifiP2pManager.WIFI_P2P_STATE_ENABLED -> {
--                         // Wifi P2P is enabled
--                     }
--@@ -50,20 +52,39 @@
--                 // The peer list has changed! We should probably do something about that.
--                 Toast.makeText(context, "WIFI_P2P_PEERS_CHANGED_ACTION", Toast.LENGTH_SHORT).show()
-- 
---                manager.requestPeers(channel, object : WifiP2pManager.PeerListListener{
---                    override fun onPeersAvailable(peers: WifiP2pDeviceList?) {
---                        WifiDirectMainActivity.availablePeers.clear()
---                        WifiDirectMainActivity.availablePeers.addAll(peers!!.deviceList)
---                        mainActivity.groupList.clear()
---                        for(peer in peers!!.deviceList){
---//                            PeerRecyclerAdapter.modelList.add(GroupModel(peer.deviceName, peer.deviceAddress, peer.isGroupOwner.toString()))
---                            mainActivity.groupList.add(PeerModel(peer.deviceName, peer.deviceAddress, peer.isGroupOwner.toString()))
---                        }
---//                        availablePeers_In_BR.addAll(peers!!.deviceList)
---                        WifiDirectMainActivity.recyclerview_adapter!!.notifyDataSetChanged()
---                        // todo : recycler adapter list에 값 넣고, notify 해줄 것
---                    }
---                })
--+                if (ActivityCompat.checkSelfPermission(
--+                        this,
--+                        Manifest.permission.ACCESS_FINE_LOCATION
--+                    ) != PackageManager.PERMISSION_GRANTED
--+                ) {
--+                    // TODO: Consider calling
--+                    //    ActivityCompat#requestPermissions
--+                    // here to request the missing permissions, and then overriding
--+                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
--+                    //                                          int[] grantResults)
--+                    // to handle the case where the user grants the permission. See the documentation
--+                    // for ActivityCompat#requestPermissions for more details.
--+                    return
--+                }
--+                manager.requestPeers(channel
--+                ) { peers ->
--+                    WifiDirectMainActivity.availablePeers.clear()
--+                    WifiDirectMainActivity.availablePeers.addAll(peers!!.deviceList)
--+                    mainActivity.groupList.clear()
--+                    for (peer in peers!!.deviceList) {
--+                        //                            PeerRecyclerAdapter.modelList.add(GroupModel(peer.deviceName, peer.deviceAddress, peer.isGroupOwner.toString()))
--+                        mainActivity.groupList.add(
--+                            PeerModel(
--+                                peer.deviceName,
--+                                peer.deviceAddress,
--+                                peer.isGroupOwner.toString()
--+                            )
--+                        )
--+                    }
--+                    //                        availablePeers_In_BR.addAll(peers!!.deviceList)
--+                    WifiDirectMainActivity.recyclerview_adapter!!.notifyDataSetChanged()
--+                    // todo : recycler adapter list에 값 넣고, notify 해줄 것
--+                }
--             }
-- 
--             // WiFi P2P 연결 상태가 변경되었음을 나타냄 -> requestConnectionInfo() 호출
--Index: app/src/main/java/com/example/pic_pho/WifiDirect/FileReceiveActionThread.kt
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>package com.example.pic_pho.WifiDirect\n\nimport android.content.Context\nimport android.media.MediaScannerConnection\nimport android.util.Log\nimport java.io.*\nimport java.net.Socket\n\n// stream 받아서 파일 만들어주는 thread\nclass FileReceiveActionThread(var client : Socket, var context : Context) : Thread(){\n\n    override fun run() {\n        super.run()\n        Log.d(TAG, \"FileReceiverAction Start\")\n        var inputStream = client.getInputStream()\n\n        var filename:String = \"/storage/emulated/0\"+\"/DCIM/Picpho/\" + System.currentTimeMillis() + \".jpg\"\n        var f = File(filename)\n        Log.d(TAG, f.toString())\n\n        val dirs = File(f!!.parent.toString())\n        if (!dirs.exists()) dirs.mkdirs()\n        if (f!!.createNewFile()){\n            Log.d(TAG, \"into if\")\n            inputStream.copyTo(FileOutputStream(f))\n            Log.d(TAG, \"After copyTo\")\n            scanFile(context, f!!,\"jpg\")\n            Log.d(TAG, \"FileReceiverAction Finished\")\n            client.close()\n        }\n    }\n\n    companion object {\n\n        private const val TAG = \"FileReceiveAction\"\n\n        fun scanFile(context: Context?, f: File, mimeType: String) {\n            Log.d(TAG, \"scanFile: is here?\")\n            MediaScannerConnection\n                .scanFile(context, arrayOf(f.absolutePath), arrayOf(mimeType), null)\n        }\n    }\n}\n\n\n
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
----- app/src/main/java/com/example/pic_pho/WifiDirect/FileReceiveActionThread.kt	(revision 11603d9e053b9d90d4d3b9e368881341da1bf204)
--+++ app/src/main/java/com/example/pic_pho/WifiDirect/FileReceiveActionThread.kt	(date 1616316499000)
--@@ -6,7 +6,6 @@
-- import java.io.*
-- import java.net.Socket
-- 
---// stream 받아서 파일 만들어주는 thread
-- class FileReceiveActionThread(var client : Socket, var context : Context) : Thread(){
-- 
--     override fun run() {
--Index: app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectMainActivity.kt
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>package com.example.pic_pho.WifiDirect\n\nimport android.Manifest\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.net.wifi.WpsInfo\nimport android.net.wifi.p2p.*\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.StrictMode\nimport android.provider.MediaStore\nimport android.util.Log\nimport android.widget.TextView\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.pic_pho.R\nimport com.example.pic_pho.WifiDirect.UI.PeerModel\nimport com.example.pic_pho.WifiDirect.UI.PeerRecyclerAdapter\nimport com.example.pic_pho.WifiDirect.UI.PeerViewHolder\nimport kotlinx.android.synthetic.main.activity_room.*\nimport org.jetbrains.anko.toast\n\n//import com.skyfishjy.library.RippleBackground\n\n\nclass WifiDirectMainActivity : AppCompatActivity() {\n\n    var isGroupOwner = false;\n    var groupList = ArrayList<PeerModel>()\n\n    companion object {\n        var outputstreamList = ArrayList<Uri>()\n        var groupownerAddr: String? = null;\n        val availablePeers = ArrayList<WifiP2pDevice>()\n        var manager: WifiP2pManager? = null\n        var channel: WifiP2pManager.Channel? = null\n        var recyclerview_adapter: RecyclerView.Adapter<PeerViewHolder>? = null\n        var receiver: BroadcastReceiver? = null\n        var textView_OG: TextView? = null\n    }\n\n\n    private lateinit var intentFilter: IntentFilter\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n\n        Log.d(\"onCreate\", \"Create\")\n\n        var builder = StrictMode.VmPolicy.Builder()\n        StrictMode.setVmPolicy(builder.build())\n\n        manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_room)\n\n        textView_OG = tv_test\n        // 앱 실행 시, 권한 묻기 (위치 정보(Wifi-D 사용) 및 스토리지(갤러리) 접근 권한)\n        requestPermissionToUser()\n\n        recyclerview_adapter = PeerRecyclerAdapter()\n        (recyclerview_adapter as PeerRecyclerAdapter).submitList(groupList)\n\n        rv_room.apply {\n            layoutManager =\n                LinearLayoutManager(this@WifiDirectMainActivity, LinearLayoutManager.VERTICAL, false)\n            adapter = recyclerview_adapter\n        }\n\n        // WifiP2PManager 객체 초기화(initailize 함수 호출)\n        channel = manager?.initialize(this, mainLooper, null)\n\n        // BroadCast Receiver 객체 초기화\n//        channel?.also { channel ->\n//        receiver = MyReceiver(manager!!, channel!!, this)\n//        }\n\n        // BroadCast Receiver에게 해당 Action들을 Listen하도록 필터링\n        intentFilter = IntentFilter().apply {\n            addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION) // 기기에서 Wi-Fi P2P가 활성화되었거나 비활성화되었는지 브로드캐스트합니다.\n            addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION) // discoverPeers()를 호출할 때 브로드캐스트합니다. 일반적으로는 이 인텐트를 애플리케이션에서 처리할 경우, requestPeers()를 호출하여 피어의 업데이트된 목록을 가져올 것입니다.\n            addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) // 기기의 Wi-Fi 연결 상태가 변경되면 브로드캐스트합니다.\n            addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION) // 기기의 상세 정보(예: 기기 이름)가 변경되었는지 브로드캐스트합니다.\n        }\n\n\n        // Peer 연결하기\n        btn_room_selectpic.setOnClickListener {\n\n            if (availablePeers.isNotEmpty()) {\n\n                for (peer in availablePeers) {\n\n                    // list에서 가져온 특정 Peer -> 실제 구현에서는 list 순회하면서 모든 peer들에게 connect 해야 할 것\n                    val device: WifiP2pDevice = peer\n\n                    // 연결할 Peer에 대한 추가적인 정보\n                    val config = WifiP2pConfig().apply {\n                        deviceAddress = device.deviceAddress\n                        groupOwnerIntent =\n                            15 // 해당 Peer가 Client가 되도록 우선순위 할당 (15를 줬을 경우에는, Connect 자체가 이뤄지지 않음.... 왜지...)\n                        wps.setup =\n                            WpsInfo.PBC // 이 내용은 잘 모르겠음.. wps = Wi-Fi Protected Setup임 -> 알아볼 것\n                    }\n\n                    // 지정한 Peer에게 연결 요청을 보냄\n                    manager?.connect(\n                        channel,\n                        config,\n                        object : WifiP2pManager.ActionListener {\n                            override fun onSuccess() {\n                                toast(\"Connect success\")\n                            }\n\n                            override fun onFailure(reason: Int) {\n                                toast(\"Connect fail : ${reason}\")\n                            }\n                        }\n                    )\n                }\n            } else {\n                toast(\"Peer 리스트가 비었습니다.\")\n            }\n        }\n\n        // Peer 검색\n        btn_connect.setOnClickListener {\n//            val rippleBackground = findViewById<View>(R.id.contentInRoom) as RippleBackground\n//            rippleBackground.startRippleAnimation()\n            manager?.discoverPeers(channel, object : WifiP2pManager.ActionListener {\n                override fun onSuccess() {\n                    toast(\"피어 찾기 시작\")\n                }\n\n                override fun onFailure(reason: Int) {\n                    toast(\"피어 찾기 실패\")\n                }\n\n\n            })\n        }\n\n        // 현재 만든 그룹정보 확인\n        btn_createGroup.setOnClickListener {\n            removeGroup()\n//            manager!!.requestGroupInfo(channel, object : WifiP2pManager.GroupInfoListener {\n//                override fun onGroupInfoAvailable(group: WifiP2pGroup?) {\n//\n//                    if (group != null) {\n//                        manager!!.removeGroup(channel, object : WifiP2pManager.ActionListener {\n//                            override fun onSuccess() {\n//                                Toast.makeText(\n//                                    applicationContext,\n//                                    \"group successfully removed\",\n//                                    Toast.LENGTH_SHORT\n//                                ).show()\n//                                isGroupOwner = false;\n//                                RoomActivity.textView_OG!!.text = \"anonymous\"\n//                            }\n//\n//                            override fun onFailure(reason: Int) {\n//                                Toast.makeText(\n//                                    applicationContext,\n//                                    \"group remove failed \",\n//                                    Toast.LENGTH_SHORT\n//                                ).show()\n//                            }\n//                        })\n//                    }\n//                }\n//            })\n        }\n\n        // 현재 만든 그룹정보 확인\n        btn_checkGroup.setOnClickListener {\n            manager!!.requestGroupInfo(channel, object : WifiP2pManager.GroupInfoListener {\n                override fun onGroupInfoAvailable(group: WifiP2pGroup?) {\n\n                    if (group != null) {\n                        Log.d(\n                            \"group_Info : \",\n                            \"==============================================================\"\n                        )\n                        Log.d(\"group_Info : \", group!!.clientList.toString())\n                        Log.d(\"group_Info : \", group!!.networkName.toString())\n                        Log.d(\"group_Info : \", group!!.isGroupOwner.toString())\n                        Log.d(\"group_Info : \", group!!.owner.toString())\n                        Log.d(\n                            \"group_Info : \",\n                            \"==============================================================\"\n                        )\n                    }\n                }\n            })\n        }\n\n        btn_connectInfo.setOnClickListener {\n            manager!!.requestDeviceInfo(channel!!, object : WifiP2pManager.DeviceInfoListener {\n                override fun onDeviceInfoAvailable(wifiP2pDevice: WifiP2pDevice?) {\n                    Log.d(\"ConnectInfo : \", \"===================================================\")\n                    Log.d(\"ConnectInfo : \", wifiP2pDevice.toString())\n                    Log.d(\"ConnectInfo : \", \"===================================================\")\n                }\n            })\n        }\n\n        btn_cancel.setOnClickListener {\n//            val rippleBackground = findViewById<View>(R.id.contentInRoom) as RippleBackground\n//            rippleBackground.stopRippleAnimation()\n\n\n            manager!!.cancelConnect(channel, object : WifiP2pManager.ActionListener {\n                override fun onSuccess() {\n                    Log.d(\"cancelConnect : \", \"===================================================\")\n                    Log.d(\"cancelConnect : \", \"success\")\n                    Log.d(\"cancelConnect : \", \"===================================================\")\n                }\n\n                override fun onFailure(reason: Int) {\n                    Log.d(\"cancelConnect : \", \"===================================================\")\n                    Log.d(\"cancelConnect : \", \"Failure\")\n                    Log.d(\"cancelConnect : \", \"===================================================\")\n                }\n            })\n        }\n\n        btn_gallery.setOnClickListener {\n            var intent = Intent(Intent.ACTION_PICK)\n            intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n            intent.data = MediaStore.Images.Media.EXTERNAL_CONTENT_URI\n            intent.type = \"image/*\"\n            startActivityForResult(intent, 100)\n        }\n        btn_send.setOnClickListener {\n\n            if (groupownerAddr != null) {\n                Log.d(\"Client Side\", \"Send Btn Clicked\")\n                val intent = Intent(this, SendStreamIntentService::class.java)\n\n                Log.d(\"사진 URI\", outputstreamList.toString())\n\n                for(uri in outputstreamList) {\n                    intent.putExtra(\"go_host\", groupownerAddr)\n                    intent.putExtra(\"go_port\", 8989)\n                    intent.putExtra(\"uri\", uri.toString())\n                    intent.setAction(\"com.example.picpho.CONNECT_TO_SERVER\")\n                    startService(intent)\n                }\n            }\n        }\n\n\n    }\n\n    // BroadCast Receiver를 등록한다.\n    override fun onResume() {\n        super.onResume()\n        Log.d(\"onResume\", \"onResume\")\n        receiver = WifiDirectBroadcastReceiver(manager!!, channel!!, this)\n        registerReceiver(receiver, intentFilter)\n    }\n\n    // BroadCast Receiver를 등록해제 한다.\n    override fun onPause() {\n        super.onPause()\n        Log.d(\"onPuase\", \"onPuase\")\n        unregisterReceiver(receiver)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"onDestroy\", \"onDestroy\")\n\n        if (WifiDirectBroadcastReceiver.ServerThread != null && !WifiDirectBroadcastReceiver.ServerThread!!.isCancelled) {\n            WifiDirectBroadcastReceiver.ServerThread!!.cancel(false)\n        }\n\n        removeGroup()\n    }\n\n    fun removeGroup(){\n        manager!!.requestGroupInfo(channel, object : WifiP2pManager.GroupInfoListener {\n            override fun onGroupInfoAvailable(group: WifiP2pGroup?) {\n\n                if (group != null) {\n                    manager!!.removeGroup(channel, object : WifiP2pManager.ActionListener {\n                        override fun onSuccess() {\n                            Toast.makeText(\n                                applicationContext,\n                                \"group successfully removed\",\n                                Toast.LENGTH_SHORT\n                            ).show()\n                            isGroupOwner = false;\n                            textView_OG!!.text = \"anonymous\"\n                        }\n\n                        override fun onFailure(reason: Int) {\n                            Toast.makeText(\n                                applicationContext,\n                                \"group remove failed \",\n                                Toast.LENGTH_SHORT\n                            ).show()\n                        }\n                    })\n                }\n            }\n        })\n    }\n\n\n    fun connectToPeer(deviceAddr: String) {\n        if (availablePeers.isNotEmpty()) {\n            for (peer in availablePeers) {\n                // list에서 가져온 특정 Peer -> 실제 구현에서는 list 순회하면서 모든 peer들에게 connect 해야 할 것\n\n                val device: WifiP2pDevice = peer\n                Log.d(\"connectToPeer : \", \"===================================================\")\n                Log.d(\"connectToPeer : \", device.toString())\n                Log.d(\"connectToPeer : \", \"===================================================\")\n\n                // 연결할 Peer에 대한 추가적인 정보\n                val config = WifiP2pConfig().apply {\n                    deviceAddress = deviceAddr\n                    groupOwnerIntent =\n                        15 // 해당 Peer가 Client가 되도록 우선순위 할당 (15를 줬을 경우에는, Connect 자체가 이뤄지지 않음.... 왜지...)\n                    wps.setup =\n                        WpsInfo.PBC // 이 내용은 잘 모르겠음.. wps = Wi-Fi Protected Setup임 -> 알아볼 것\n                }\n\n                Log.d(\"connectToPeer : \", \"===================================================\")\n                Log.d(\"connectToPeer : \", manager.toString())\n                Log.d(\"connectToPeer : \", \"===================================================\")\n\n                // 지정한 Peer에게 연결 요청을 보냄\n                manager?.connect(\n                    channel,\n                    config,\n                    object : WifiP2pManager.ActionListener {\n                        override fun onSuccess() {\n//                            toast(\"Connect success\")\n                            Log.d(\n                                \"connectToPeer : \",\n                                \"===================================================\"\n                            )\n                            Log.d(\"connectToPeer : \", \"3\")\n                            Log.d(\n                                \"connectToPeer : \",\n                                \"===================================================\"\n                            )\n                        }\n\n                        override fun onFailure(reason: Int) {\n//                            toast(\"Connect fail : ${reason}\")\n                            Log.d(\n                                \"connectToPeer : \",\n                                \"===================================================\"\n                            )\n                            Log.d(\"connectToPeer : \", \"4\")\n                            Log.d(\n                                \"connectToPeer : \",\n                                \"===================================================\"\n                            )\n                        }\n                    }\n                )\n            }\n        } else {\n//            toast(\"Peer 리스트가 비었습니다.\")\n            Log.d(\"connectToPeer : \", \"===================================================\")\n            Log.d(\"connectToPeer : \", \"리스트가 비었습니다\")\n            Log.d(\"connectToPeer : \", \"===================================================\")\n        }\n    }\n\n\n    // 권한 요청 부분(우리는 갤러리를 위한 WRITE / READ, WiFi - D를 위한 LOCATION, INTERNET이 필요함) -> 권한 부분도 구멍이 많아서 처리해줘야함!!!\n    fun requestPermissionToUser() {\n        var writePermission =\n            ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n        var readPermission =\n            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)\n        var locationPermission =\n            ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)\n\n        if (writePermission == PackageManager.PERMISSION_DENIED || readPermission == PackageManager.PERMISSION_DENIED || locationPermission == PackageManager.PERMISSION_DENIED) {\n            ActivityCompat.requestPermissions(\n                this,\n                arrayOf(\n                    Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    Manifest.permission.READ_EXTERNAL_STORAGE,\n                    Manifest.permission.ACCESS_FINE_LOCATION\n                ),\n                1\n            )\n        }\n    }\n\n    // 갤러리에서 화면으로 돌아왔을 때, 처리할 부분\n    @RequiresApi(Build.VERSION_CODES.P)\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        when (requestCode) {\n\n            100 -> {\n                if (data != null) {\n//                var metadata = data!!.clipData!!.description // metadata?\n                    var count = data!!.clipData!!.itemCount // item 선택 개수\n\n                    outputstreamList.clear()\n\n                    for (i in 0 until count) {\n                        var imageUri = data.clipData!!.getItemAt(i).uri\n//                    var source = ImageDecoder.createSource(contentResolver, imageUri)\n//                    val bitmap = MediaStore.Images.Media.getBitmap(contentResolver, imageUri)\n\n//                        val outputData = this.contentResolver.openOutputStream(Uri.parse(imageUri.toString()))\n//                        outputstreamList.add(outputData!!)\n                        outputstreamList.add(imageUri)\n                        Log.d(\"onActivityResult\", outputstreamList.size.toString())\n                    }\n                }\n            }\n        }\n    }\n}
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
----- app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectMainActivity.kt	(revision 11603d9e053b9d90d4d3b9e368881341da1bf204)
--+++ app/src/main/java/com/example/pic_pho/WifiDirect/WifiDirectMainActivity.kt	(date 1616317555000)
--@@ -130,7 +130,7 @@
--                 toast("Peer 리스트가 비었습니다.")
--             }
--         }
---
--+햣 ㅔㅕ
--         // Peer 검색
--         btn_connect.setOnClickListener {
-- //            val rippleBackground = findViewById<View>(R.id.contentInRoom) as RippleBackground
Index: .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM__Default_Changelist_.xml	(revision 62cc028e88373d16c82c87c5ff01d3eb99f236c3)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM__Default_Changelist_.xml	(revision 62cc028e88373d16c82c87c5ff01d3eb99f236c3)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_3_30_21_2_21_AM_[Default_Changelist]" date="1617038495335" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_3_30_21_2_21_AM_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 3/30/21 2:21 AM [Default Changelist]" />
-</changelist>
\ No newline at end of file
